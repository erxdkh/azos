/*<FILE_LICENSE>
 * Azos (A to Z Application Operating System) Framework
 * The A to Z Foundation (a.k.a. Azist) licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
</FILE_LICENSE>*/

using Azos.Collections;
using System;
using System.Collections;
using System.Linq;

namespace Azos.Data
{
  /// <summary>
  /// Defines mode of validation error generation: whether the system should stop validation on the
  /// very first error (if any), or should continue validating generating more errors (which can take longer)
  /// </summary>
  public enum ValidErrorMode : byte
  {
    /// <summary>
    /// Validations trips on a first validation error found. This is the fastest method but
    /// the caller would only get one error at a time
    /// </summary>
    Single = 0,

    /// <summary>
    /// The system would try to validate more items (such as fields) at once even if validation errors
    /// have been triggered, as long as these validation calls do not slow the system down significantly (e.g. no external calls).
    /// The definition of 'fast' is up to a concrete implementation as this flag is just a hint, for example: in a
    /// complex custom validation routine this flag should prevent making long IO calls
    /// </summary>
    FastBatch = 1,

    /// <summary>
    /// The system will try to validate as many items as it can in the presence of validation failures,
    /// regardless of possible performance issues
    /// </summary>
    Batch = 2
  }

  /// <summary>
  /// Encapsulates validation state passed around between `Validate(state)` calls.
  /// This is an immutable struct by design and one changes the state by allocating a new instance, deriving
  /// its current state from an existing one in a functional style: `state = new ValidState(state, error)`.
  /// This is done for performance (avoids extra object allocation) and simplicity.
  /// The Error property contains either a single validation error or an error batch which contains multiple error instances
  /// produced while validating different parts of data document graph.
  /// </summary>
  /// <remarks>
  /// The system is purposely built not to create extra object instances for every validate call, as sometimes
  /// we need to validate hundreds of thousands of doc instances a second in high load applications.
  /// The errors are created and returned, but not thrown as throw is a very expensive operation.
  /// Under normal conditions, validation does not find any errors and does not cause any extra allocation just for
  /// validation that would have been required had a class been used instead
  /// </remarks>
  public struct ValidState
  {
    public const int DEFAULT_ERROR_LIMIT = 50;
    public const int MAX_ERROR_LIMIT = 7_000;

    /// <summary>
    /// Allocates new validation state without errors.
    /// If validation succeeds the Validate method succession shall return a copy of this state
    /// </summary>
    /// <param name="targetName">The target name to perform validation under. Controls attribute/metadata selection</param>
    /// <param name="mode">A hint specifying whether the system shall break on the first error or continue with error batch</param>
    /// <param name="errorLimit">Sets an approximate limit for total error count generated by validation in batch mode</param>
    /// <param name="context">Passes an optional business-centric context into validation chain</param>
    public ValidState(string targetName, ValidErrorMode mode, int errorLimit = DEFAULT_ERROR_LIMIT, object context = null)
    {
      TargetName = targetName ?? TargetedAttribute.ANY_TARGET;
      Mode = mode;
      Error = null;
      ErrorLimit = IntUtils.MinMax(1, errorLimit, MAX_ERROR_LIMIT);
      Context = context;//may be null
    }

    /// <summary>
    /// Allocates a new validation state with the specified error added to the existing state
    /// </summary>
    /// <param name="existing">Existing context state that the new state will be based on</param>
    /// <param name="error">An error to return</param>
    public ValidState(ValidState existing, Exception error)
    {
      if (!existing.IsAssigned)
        throw new CallGuardException(nameof(ValidState)+".ctor", nameof(existing), "Unassigned");

      TargetName = existing.TargetName;
      Mode = existing.Mode;
      Error = ValidationBatchException.Concatenate(existing.Error, error);
      ErrorLimit = existing.ErrorLimit;
      Context = existing.Context;
    }

    /// <summary>
    /// Allocates a new validation state with a different context value
    /// </summary>
    /// <param name="existing">Existing context state that the new state will be based on</param>
    /// <param name="context">Passes an optional business-centric context into validation chain</param>
    public ValidState(ValidState existing, object context)
    {
      if (!existing.IsAssigned)
        throw new CallGuardException(nameof(ValidState) + ".ctor", nameof(existing), "Unassigned");

      TargetName = existing.TargetName;
      Mode = existing.Mode;
      Error = existing.Error;
      ErrorLimit = existing.ErrorLimit;
      Context = context;
    }

    /// <summary>
    /// The target name of the validation to be performed against. This controls metadata applicable to specific
    /// validation
    /// </summary>
    public readonly string TargetName;

    /// <summary>
    /// Describes the mode of validation: Single error vs Error Batch
    /// </summary>
    public readonly ValidErrorMode Mode;

    /// <summary>
    /// Returns validation error or errors. Returns null if there are no validation errors
    /// </summary>
    public readonly Exception Error;

    /// <summary>
    /// Sets an approximate limit for total error count generated by Validate()
    /// </summary>
    public readonly int ErrorLimit;

    /// <summary>
    /// Passes an optional business-centric context into validation chain
    /// </summary>
    public readonly object Context;

    /// <summary>
    /// True if this is NOT a default instance which was created using parameterized .ctor
    /// </summary>
    public bool IsAssigned => TargetName != null;

    /// <summary>
    /// There are validation errors in this state object
    /// </summary>
    public bool HasErrors => Error != null;

    /// <summary>
    /// There are no validation errors in this state object
    /// </summary>
    public bool NoErrors => Error == null;

    /// <summary>
    /// Returns true when validation should continue that is:
    ///  when no errors have been detected OR mode is set to batch and total error count is below the ErrorLimit
    /// </summary>
    public bool ShouldContinue => NoErrors || (Mode > ValidErrorMode.Single && ErrorCount < ErrorLimit);

    /// <summary>
    /// An inverse of ShouldContinue: validation shall stop when there is an error in an single mode, or mode is batch and total
    /// error count exceeds or equal to the ErrorLimit
    /// </summary>
    public bool ShouldStop => !ShouldContinue;

    /// <summary>
    /// Error count batched in the state instance
    /// </summary>
    public int ErrorCount => Error==null ? 0 : Error is ValidationBatchException vbe ? vbe.Batch.Count : 1;

    public override string ToString() => $"ValState(`{TargetName}`)";

    /// <summary>
    /// Performs validation checks one by one returning as soon as the validation should stop.
    /// This is a syntax sugar not to write `if (state.ShouldStop()) return state;` every time
    /// </summary>
    public ValidState Of(Func<ValidState, ValidState> f1,
                         Func<ValidState, ValidState> f2,
                         Func<ValidState, ValidState> f3 = null,
                         Func<ValidState, ValidState> f4 = null,
                         Func<ValidState, ValidState> f5 = null,
                         Func<ValidState, ValidState> f6 = null,
                         Func<ValidState, ValidState> f7 = null,
                         Func<ValidState, ValidState> f8 = null)
    {
      var state = this;

      if (f1 != null) { state = f1(state); if (state.ShouldStop) return state; }
      if (f2 != null) { state = f2(state); if (state.ShouldStop) return state; }
      if (f3 != null) { state = f3(state); if (state.ShouldStop) return state; }
      if (f4 != null) { state = f4(state); if (state.ShouldStop) return state; }
      if (f5 != null) { state = f5(state); if (state.ShouldStop) return state; }
      if (f6 != null) { state = f6(state); if (state.ShouldStop) return state; }
      if (f7 != null) { state = f7(state); if (state.ShouldStop) return state; }
      if (f8 != null) state = f8(state);

      return state;
    }

    /// <summary>
    /// Performs validation checks one by one returning as soon as the validation should stop.
    /// This is a syntax sugar not to write `if (state.ShouldStop()) return state;` every time.
    /// This version of the function passes a TContext value between calls
    /// </summary>
    public ValidState Of<TContext>(TContext ctx,
                                   Func<TContext, ValidState, ValidState> f1,
                                   Func<TContext, ValidState, ValidState> f2,
                                   Func<TContext, ValidState, ValidState> f3 = null,
                                   Func<TContext, ValidState, ValidState> f4 = null,
                                   Func<TContext, ValidState, ValidState> f5 = null,
                                   Func<TContext, ValidState, ValidState> f6 = null,
                                   Func<TContext, ValidState, ValidState> f7 = null,
                                   Func<TContext, ValidState, ValidState> f8 = null)
    {
      var state = this;

      if (f1 != null) { state = f1(ctx, state); if (state.ShouldStop) return state; }
      if (f2 != null) { state = f2(ctx, state); if (state.ShouldStop) return state; }
      if (f3 != null) { state = f3(ctx, state); if (state.ShouldStop) return state; }
      if (f4 != null) { state = f4(ctx, state); if (state.ShouldStop) return state; }
      if (f5 != null) { state = f5(ctx, state); if (state.ShouldStop) return state; }
      if (f6 != null) { state = f6(ctx, state); if (state.ShouldStop) return state; }
      if (f7 != null) { state = f7(ctx, state); if (state.ShouldStop) return state; }
      if (f8 != null) state = f8(ctx, state);

      return state;
    }

  }


  public partial class Doc
  {
    /// <summary>
    /// Performs validation of data in the document returning exception object that provides description
    /// in cases when validation does not pass. Validation is performed not targeting any particular backend (any target)
    /// </summary>
    public Exception Validate() => Validate(null);

    public Exception Validate(string targetName) => Validate(new ValidState(targetName, ValidErrorMode.Single)).Error;

    /// <summary>
    /// Validates data document using schema/supplied field definitions.
    /// Override to perform custom validations,
    /// i.e. TypeDocs may directly access properties and write some validation type-safe code.
    /// The method is not expected to throw exception in case of failed business logic validation, rather return exception instance because
    ///  throwing exception really hampers validation performance when many docs/rows need to be validated.
    /// The thrown exception indicates an unexpected condition/a bug in the validation logic itself.
    /// </summary>
    /// <param name="state">The <see cref="ValidState"/> that gets passed in and returned</param>
    /// <param name="scope">
    /// Optional logical scope name, such as a name of parent document used for complex structure validation,
    /// for example you can use the value to add to special validation exception details to include the "parent path" of validation.
    /// This is passed as a separate parameter from ValidState because in practice it is needed mostly for nested IValidatable such as
    /// custom data types so they can report a name of the field that contains them
    /// </param>
    public virtual ValidState Validate(ValidState state, string scope = null)
    {
      foreach(var fd in Schema)
      {
        state = ValidateField(state, fd, scope);
        if (state.ShouldStop) break;
      }

      return state;
    }

    /// <summary>
    /// Validates document field using Schema.FieldDef settings.
    /// This method is invoked by base Validate() implementation.
    /// The method is not expected to throw exception in case of failed validation, rather return exception instance because
    ///  throwing exception really hampers validation performance when many rows need to be validated
    /// </summary>
    public virtual ValidState ValidateField(ValidState state, Schema.FieldDef fdef, string scope = null)
    {
      if (fdef == null)
        throw new FieldValidationException(Schema.DisplayName,
                                           CoreConsts.NULL_STRING,
                                           StringConsts.ARGUMENT_ERROR + ".ValidateField(fdef=null)");

      var atr = fdef[state.TargetName];
      if (atr==null) return state; //not found per target

      var value = GetFieldValue(fdef);

      var (hasValue, error) = CheckValueRequired(state.TargetName, fdef, atr, value, scope);
      if (error != null) return new ValidState(state, error);
      if (!hasValue) return state;//nothing else left to check


      state = CheckValueIValidatable(state, fdef, atr, value, scope);
      if (state.ShouldStop) return state;

      error = CheckValueLength(state.TargetName, fdef, atr, value, scope);
      if (error != null)
      {
        state = new ValidState(state, error);
        if (state.ShouldStop) return state;
      }

      error = CheckValueKind(state.TargetName, fdef, atr, value, scope);
      if (error != null)
      {
        state = new ValidState(state, error);
        if (state.ShouldStop) return state;
      }

      error = CheckValueMinMax(state.TargetName, fdef, atr, value, scope);
      if (error != null)
      {
        state = new ValidState(state, error);
        if (state.ShouldStop) return state;
      }

      error = CheckValueRegExp(state.TargetName, fdef, atr, value, scope);
      if (error != null)
      {
        state = new ValidState(state, error);
        if (state.ShouldStop) return state;
      }

      //this is at the end as ValueList check might induce a database call  to get a pick list (when it is not cached)
      error = CheckValueList(state.TargetName, fdef, atr, value, scope);
      if (error != null)
      {
        state = new ValidState(state, error);
        if (state.ShouldStop) return state;
      }

      return state;
    }


    protected virtual (bool hasValue, Exception error) CheckValueRequired(string targetName, Schema.FieldDef fdef, FieldAttribute atr, object value, string scope)
    {
      var missing =
           (value == null) ||
           (value is string strv && strv.IsNullOrWhiteSpace()) || //string null, or whitespace are treated as missing
           (value is IRequired ireq && !ireq.CheckRequired(targetName));

      if (missing)
      {
        if (atr.Required)
          return (false, new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_REQUIRED_ERROR));

        return (false, null); //no other validations are needed as field is null anyway
      }

      return (true, null);
    }

    protected virtual Exception CheckValueLength(string targetName, Schema.FieldDef fdef, FieldAttribute atr, object value, string scope)
    {
      if (atr.MinLength < 1 && atr.MaxLength < 1) return null;

      var isString = value is string;
      var eobj = value as IEnumerable;
      var ecount = !isString && eobj != null ? eobj.Cast<object>().Count() : -1;

      if (atr.MinLength > 0)
      {
        if (ecount >= 0)
        {
          if (ecount < atr.MinLength)
            return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_MIN_LENGTH_ERROR.Args(atr.MinLength));
        }
        else
        {
          if (value.ToString().Length < atr.MinLength)
            return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_MIN_LENGTH_ERROR.Args(atr.MinLength));
        }
      }

      if (atr.MaxLength > 0)
      {
        if (ecount >= 0)
        {
          if (ecount > atr.MaxLength)
            return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_MAX_LENGTH_ERROR.Args(atr.MaxLength));
        }
        else
        {
          if (value.ToString().Length > atr.MaxLength)
            return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_MAX_LENGTH_ERROR.Args(atr.MaxLength));
        }
      }

      return null;
    }

    protected virtual Exception CheckValueKind(string targetName, Schema.FieldDef fdef, FieldAttribute atr, object value, string scope)
    {
      if (atr.Kind == DataKind.ScreenName)
      {
        if (!Azos.Text.DataEntryUtils.CheckScreenName(value.ToString()))
          return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_SCREEN_NAME_ERROR);
      }
      else if (atr.Kind == DataKind.EMail)
      {
        if (!Azos.Text.DataEntryUtils.CheckEMail(value.ToString()))
          return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_EMAIL_ERROR);
      }
      else if (atr.Kind == DataKind.Telephone)
      {
        if (!Azos.Text.DataEntryUtils.CheckTelephone(value.ToString()))
          return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_PHONE_ERROR);
      }
      else if (atr.Kind == DataKind.Uri)
      {
        if (!Uri.TryCreate(value.ToString(), UriKind.RelativeOrAbsolute, out var _))
          return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_PHONE_ERROR);
      }

      return null;
    }

    protected string GetInnerScope(Schema.FieldDef fdef, string scope) => scope.IsNullOrWhiteSpace() ? fdef.Name : scope + "." + fdef.Name;


    private static ValidState validateIValidatable(Doc self, ObjectGraph graph, IValidatable validatable, ValidState state, string scope)
    => !graph.Visited(validatable) ? validatable.Validate(state, scope) : state;

    private static ValidState validateIDictionary(Doc self, ObjectGraph graph, IDictionary dict, ValidState state, string scope)
    {
      foreach (var v in dict.Values)
      {
        if (state.ShouldStop) break;
        if (v is IValidatable vv && !graph.Visited(vv))
          state = vv.Validate(state, scope);
      }
      return state;
    }

    private static ValidState validateIEnumerable(Doc self, ObjectGraph graph, IEnumerable enm, ValidState state, string scope)
    {
      foreach (var v in enm)
      {
        if (state.ShouldStop) break;
        if (v is IValidatable vv && !graph.Visited(vv))
          state = vv.Validate(state, scope);
      }
      return state;
    }

    protected virtual ValidState CheckValueIValidatable(ValidState state, Schema.FieldDef fdef, FieldAttribute atr, object value, string scope)
    {
      //20200517 DKh using ObjectGraph.Scope()
      //--------------------------------------

      if (value is IValidatable validatable)
      {
        var got = ObjectGraph.Scope("Doc.CheckValueIValidatable.IVal", //name of the state machine
                                         this, //reference to cycle subject - the document itself
                                         validatable,//arg1
                                         state, //arg2
                                         GetInnerScope(fdef, scope),//arg3
                                         body: validateIValidatable
                                       );//machine
        return got.OK ? got.result : state;
      }

      //precedence of IFs is important, IDictionary is IEnumerable
      if (value is IDictionary dict)//Dictionary<string, IValidatable>
      {
        var got = ObjectGraph.Scope("Doc.CheckValueIValidatable.IDict",
                                          this,
                                          dict,
                                          state,
                                          GetInnerScope(fdef, scope),
                                          body: validateIDictionary
                                        );
        return got.OK ? got.result : state;
      }

      if (value is IEnumerable enm)//List<IValidatable>, IValidatable[]
      {
        var got = ObjectGraph.Scope("Doc.CheckValueIValidatable.IEnum",
                                            this,
                                            enm,
                                            state,
                                            GetInnerScope(fdef, scope),
                                            body: validateIEnumerable
                                        );
        return got.OK ? got.result : state;
      }

      return state;
    }

    /// <summary>
    ///Dynamic value lists override static ones:
    /// * If a dynamic value list is null then hard coded ValueList is enforced if it is specified;
    /// * If a dynamic list is non-null then it is enforced if it is not blank, otherwise nothing is checked;
    /// Therefore: you may return an empty non-null dynamic list to prevent application of ValueList check for specific field/target
    /// </summary>
    protected virtual Exception CheckValueList(string targetName, Schema.FieldDef fdef,  FieldAttribute atr, object value, string scope)
    {
      //try to obtain dynamic value list
      var dynValueList = GetDynamicFieldValueList(fdef, targetName, Atom.ZERO);
      if (dynValueList != null)//check dynamic list is supplied
      {
        if (dynValueList.Count == 0) return null;//Nothing to check against; this is used to return empty list to override ValueList list
        var fv = value.ToString();
        if (!dynValueList.ContainsKey(fv))
         return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_IS_NOT_IN_LIST_ERROR.Args(fv.TakeFirstChars(9, "..")));
      }
      else if (atr.HasValueList)//check ValueList dictionary
      {
        var parsed = atr.ParseValueList();
        var fv = value.ToString();
        if (!parsed.ContainsKey(fv))
          return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_IS_NOT_IN_LIST_ERROR.Args(fv.TakeFirstChars(9, "..")));
      }

      return null;
    }


    protected virtual Exception CheckValueMinMax(string targetName, Schema.FieldDef fdef, FieldAttribute atr, object value, string scope)
    {
      if (!(value is IComparable val)) return null;

      if (atr.Min != null)
      {
        var bound = atr.Min as IComparable;
        if (bound != null)
        {
            var tval = val.GetType();

            bound = Convert.ChangeType(bound, tval) as IComparable;

            if (val.CompareTo(bound)<0)
                return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_MIN_BOUND_ERROR);
        }
      }

      if (atr.Max != null)
      {
        var bound = atr.Max as IComparable;
        if (bound != null)
        {
            var tval = val.GetType();

            bound = Convert.ChangeType(bound, tval) as IComparable;

            if (val.CompareTo(bound)>0)
                return new FieldValidationException(Schema.DisplayName, fdef.Name, StringConsts.CRUD_FIELD_VALUE_MAX_BOUND_ERROR);
        }
      }

      return null;
    }

    protected virtual Exception CheckValueRegExp(string targetName, Schema.FieldDef fdef, FieldAttribute atr, object value, string scope)
    {
      if (atr.FormatRegExp.IsNotNullOrWhiteSpace())
      {
        //For those VERY RARE cases when RegExpFormat may need to be applied to complex types, i.e. StringBuilder
        //set the flag in metadata to true, otherwise regexp gets matched only for STRINGS
        var complex = atr.Metadata == null ? false
                                        : atr.Metadata
                                            .AttrByName("validate-format-regexp-complex-types")
                                            .ValueAsBool(false);
        if (complex || value is string)
        {
          if (!System.Text.RegularExpressions.Regex.IsMatch(value.ToString(), atr.FormatRegExp))
            return new FieldValidationException(Schema.DisplayName, fdef.Name,
              StringConsts.CRUD_FIELD_VALUE_REGEXP_ERROR.Args(atr.FormatDescription ?? "Input format: {0}".Args(atr.FormatRegExp)));
        }
      }

      return null;
    }

  }
}
