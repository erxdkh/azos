/*<FILE_LICENSE>
 * Azos (A to Z Application Operating System) Framework
 * The A to Z Foundation (a.k.a. Azist) licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
</FILE_LICENSE>*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

using Azos.IO;
using Azos.Data;

namespace Azos.Serialization.Arow
{
  /// <summary>
  /// Designates classes that register their single instance via a call to ArowSerializer.Register().
  /// These classes are generated by cli arow compiler
  /// </summary>
  public interface ITypeSerializationCore
  {
    void Register();
    void Serialize(TypedDoc doc, WritingStreamer streamer);
    void Deserialize(TypedDoc doc, ReadingStreamer streamer);
  }

  /// <summary>
  /// Facade for performing Arow serialization.
  /// Arow format is purposely designed for "[a]daptable [row]"/version tolerant serialization that eschews creating extra copies and
  /// object instances. The serializer is used in conjunction with cli compiler that generates type-specific static serializer cores
  /// for every type that supports the format.
  /// The serializer supports primitives, Azos intrinsics like Atom, GDID, PilePointer, NLSMap, custom TypedDocs and List/arrays of the aforementioned types
  /// </summary>
  /// <remarks>
  /// By design this serializer does not support polymorphic TypedDoc types in this version
  /// </remarks>
  public static class ArowSerializer
  {
    public const string AROW_TARGET = "AROW-SERIALIZER";

    private static object s_Lock = new object();
    private static volatile Dictionary<Type, ITypeSerializationCore> s_Serializers = new Dictionary<Type, ITypeSerializationCore>();


    /// <summary>
    /// Registers all Arow type serialization cores in the satellite assembly of the calling assembly.
    /// A satellite assembly is the one that is called the same name as the calling assembly with ".Serialization" suffix, co-located with the calling assembly
    /// </summary>
    public static void RegisterTypeSerializationSatelliteForThisAssembly()
    {
      var thisAssembly = Assembly.GetCallingAssembly();
      RegisterTypeSerializationSatelliteFor(thisAssembly);
    }

    /// <summary>
    /// Registers all Arow type serialization cores in the satellite assembly of the specifies assembly.
    /// A satellite assembly is the one that is called the same name with ".Serialization" suffix, co-located with the specified assembly
    /// </summary>
    public static void RegisterTypeSerializationSatelliteFor(Assembly assembly)
    {
      const string SUFFIX = ".dll";

      var asmFileName = assembly.NonNull(nameof(assembly)).Location.Trim();
      var i = asmFileName.LastIndexOf(SUFFIX);
      if (i != asmFileName.Length - SUFFIX.Length)
        throw new ArowException(StringConsts.AROW_SATELLITE_ASSEMBLY_NAME_ERROR.Args(asmFileName));

      asmFileName = asmFileName.Substring(0, i) + ".Serialization.dll";

      try
      {
        var asm = Assembly.LoadFrom(asmFileName);
        RegisterTypeSerializationCores(asm);
      }
      catch(Exception error)
      {
        throw new ArowException(StringConsts.AROW_SATELLITE_ASSEMBLY_LOAD_ERROR.Args(asmFileName, error.ToMessageWithType()), error);
      }
    }


    /// <summary>
    /// Registers all entities in the specified assembly which implement ITypeSerializationCore interface
    /// </summary>
    public static void RegisterTypeSerializationCores(Assembly asm)
    {
      var allTypes = asm.NonNull(nameof(asm)).GetTypes();
      var allSerCores = allTypes.Where(t => t.IsClass && !t.IsAbstract && typeof(ITypeSerializationCore).IsAssignableFrom(t));

      foreach (var t in allSerCores)
      {
        var core = Activator.CreateInstance(t) as ITypeSerializationCore;
        core.Register();
      }
    }


    private const int INITIAL_BUFFER_CAPACITY = 4 * 1024;//Typical "business" object has 15 8 byte fields, and 10 32 byte fields < 700 bytes
    private const int BUFFER_TRIM_CAPACITY = 128 * 1024;

    //TLS is used since this is 100% sync CPU-bound operation
    [ThreadStatic] private static MemoryStream ts_WriteStream;
    [ThreadStatic] private static WritingStreamer ts_Writer;
    [ThreadStatic] private static Subarray<byte> ts_Subarray;
    [ThreadStatic] private static BufferSegmentReadingStream ts_ReadStream;
    [ThreadStatic] private static ReadingStreamer ts_Reader;

    /// <summary>
    /// Serializes a data document instance into a Subarray&lt;byte&gt; delimited chunk of thread-local buffer.
    /// Because sub-arrays are used for thread-local optimizations, this method should be used in a synchronous-only
    /// thread-bound flows, such as serializing payload into Pile and the returned object must be consumed right away as subsequent calls
    /// to this method will overwrite the previous content as the same thread local physical buffer is re-used.
    /// </summary>
    public static Subarray<byte> SerializeToSubarray(TypedDoc doc)
    {
      var stream = ts_WriteStream;
      var writer = ts_Writer;
      var result = ts_Subarray;

      if (stream==null)
      {
        stream = new MemoryStream(INITIAL_BUFFER_CAPACITY);
        writer = SlimFormat.Instance.GetWritingStreamer();
        writer.BindStream(stream);
        result = new Subarray<byte>();
        ts_WriteStream = stream;
        ts_Writer = writer;
        ts_Subarray = result;
      }

      stream.Position = 0;
      Serialize(doc, writer, true);

      result.Set(stream.GetBuffer(), (int)stream.Position);

      //don't let large hunk dangling in the TLS
      if (stream.Capacity>BUFFER_TRIM_CAPACITY)
      {
        stream.SetLength(0);
        stream.Capacity = INITIAL_BUFFER_CAPACITY;
      }

      return result;
    }


    public static void Serialize(TypedDoc doc, WritingStreamer streamer, bool header = true)
    {
      ITypeSerializationCore core;
      var tRow = doc.GetType();
      if (!s_Serializers.TryGetValue(tRow, out core))
        throw new ArowException(StringConsts.AROW_TYPE_NOT_SUPPORTED_ERROR.Args(tRow.FullName));

      var ar = doc as IAmorphousData;
      if (ar!=null)
      {
        if (ar.AmorphousDataEnabled) ar.BeforeSave(AROW_TARGET);
      }

      //1 Header
      if (header) Writer.WriteHeader(streamer);

          //2 Body
          core.Serialize(doc, streamer);

      //3 EORow
      Writer.WriteEORow(streamer);
    }

    /// <summary>
    /// Deserializes data document from the specified byte[] using thread-local caching optimizations
    /// </summary>
    public static void Deserialize(TypedDoc doc, byte[] data, int offset)
    {
      var stream = ts_ReadStream;
      var reader = ts_Reader;
      if (stream == null)
      {
        stream = new BufferSegmentReadingStream();
        reader = SlimFormat.Instance.GetReadingStreamer();
        reader.BindStream(stream);
        ts_ReadStream = stream;
        ts_Reader = reader;
      }

      stream.BindBuffer(data, offset, data.Length - offset);
      try
      {
        Deserialize(doc, reader, true);
      }
      finally
      {
        stream.UnsafeBindBuffer(null, 0, 0);
      }
    }

    public static void Deserialize(TypedDoc doc, ReadingStreamer streamer, bool header = true)
    {
      var ok = TryDeserialize(doc, streamer, header);
      if (!ok)
        throw new ArowException(StringConsts.AROW_TYPE_NOT_SUPPORTED_ERROR.Args(doc.GetType().FullName));
    }

    public static bool TryDeserialize(TypedDoc doc, ReadingStreamer streamer, bool header = true)
    {
      ITypeSerializationCore core;
      var tDoc = doc.GetType();
      if (!s_Serializers.TryGetValue(tDoc, out core))
        return false;

      //1 Header
      if (header) Reader.ReadHeader(streamer);

      //2 Body
      core.Deserialize(doc, streamer);

      var ar = doc as IAmorphousData;
      if (ar!=null)
      {
        if (ar.AmorphousDataEnabled) ar.AfterLoad(AROW_TARGET);
      }

      return true;
    }

    public static bool IsDocTypeSupported(Type tDoc)
    {
      return s_Serializers.ContainsKey(tDoc);
    }

    /// <summary>
    /// Registers ITypeSerializationCore so it can be used globally to serialize TypedRows in Arow format
    /// </summary>
    public static bool Register(Type tRow, ITypeSerializationCore core)
    {
      lock(s_Lock)
      {
        if (s_Serializers.ContainsKey(tRow)) return false;
        var dict = new Dictionary<Type, ITypeSerializationCore>(s_Serializers);
        dict.Add(tRow, core);
        System.Threading.Thread.MemoryBarrier();
        s_Serializers = dict;//atomic
        return true;
      }
    }
  }
}
